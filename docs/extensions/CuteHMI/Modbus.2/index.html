<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.2.0" />
<meta http-equiv="Content-Type" content=
"text/xhtml; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.14" />
<meta name="viewport" content=
"width=device-width, initial-scale=1" />
<title>CuteHMI - Modbus (CuteHMI.Modbus.2): Modbus</title>
<link href="tabs.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js">
</script>
<script type="text/javascript" src="dynsections.js">
</script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js">
</script>
<script type="text/javascript" src="navtreedata.js">
</script>
<script type="text/javascript" src="navtree.js">
</script>
<script type="text/javascript">
//<![CDATA[
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */
//]]>
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js">
</script>
<script type="text/javascript" src="search/search.js">
</script>
<script type="text/javascript">
//<![CDATA[
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
//]]>
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
<tbody>
<tr style="height: 56px;">
<td id="projectlogo"><img alt="Logo" src="project_logo.png" /></td>
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">CuteHMI - Modbus (CuteHMI.Modbus.2)
&nbsp;<span id="projectnumber">2.0.0</span></div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
//<![CDATA[
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
//]]>
</script>
<div id="navrow1" class="tabs">
<ul class="tablist">
<li><a href=
"../../../index.html"><span>Main&nbsp;Page</span></a></li>
<li><a href=
"../../../extensions_list.html"><span>Extensions</span></a></li>
<li><a href="../../../tools_list.html"><span>Tools</span></a></li>
<li class="current"><a href=
"index.html"><span>Overview</span></a></li>
<li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
<li><a href="namespaces.html"><span>Namespaces</span></a></li>
<li><a href="annotated.html"><span>Classes</span></a></li>
<li>
<div id="MSearchBox" class="MSearchBoxInactive"><span class=
"left"><img id="MSearchSelect" src="search/mag_sel.png"
onmouseover="return searchBox.OnSearchSelectShow()" onmouseout=
"return searchBox.OnSearchSelectHide()" alt="" name=
"MSearchSelect" /> <input type="text" id="MSearchField" value=
"Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)"
onblur="searchBox.OnSearchFieldFocus(false)" onkeyup=
"searchBox.OnSearchFieldChange(event)" /></span> <span class=
"right"><a id="MSearchClose" href=
"javascript:searchBox.CloseResultsWindow()" name=
"MSearchClose"><img id="MSearchCloseImg" border="0" src=
"search/close.png" alt="" name=
"MSearchCloseImg" /></a></span></div>
</li>
</ul>
</div>
</div>
<!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
<div id="nav-tree">
<div id="nav-tree-contents">
<div id="nav-sync" class="sync"></div>
</div>
</div>
<div id="splitbar" style="-moz-user-select:none;" class=
"ui-resizable-handle"></div>
</div>
<script type="text/javascript">
//<![CDATA[
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
//]]>
</script>
<div id="doc-content"><!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover=
"return searchBox.OnSearchSelectShow()" onmouseout=
"return searchBox.OnSearchSelectHide()" onkeydown=
"return searchBox.OnSearchSelectKey(event)"></div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow"><iframe src="javascript:void(0)"
frameborder="0" name="MSearchResults" id=
"MSearchResults"></iframe></div>
<div class="header">
<div class="headertitle">
<div class="title">Modbus</div>
</div>
</div>
<!--header-->
<div class="contents">
<div class="textblock">
<p>This extension provides support for Modbus protocol. Its main
purpose is to allow for configuring and interacting with Modbus
devices from QML.</p>
<p>Modbus is an industrial communcation protocol originally
designed by Modicon to be used with a series of their PLCs
(Programmable Logic Controllers). It is still one of the most
popular protocols used in automation and many devices support
Modbus as their communication interface.</p>
<h2>Device classes</h2>
<p>Modbus devices can be divided into two basic categories: servers
and clients. In Modbus nomenclature clients are often called
masters and servers are called slaves.</p>
<p>Modbus is a higher level protocol <a href=
"https://www.ni.com/pl-pl/innovations/white-papers/14/the-modbus-protocol-in-depth.html">
[1]</a> <a href=
"https://www.prosoft-technology.com/kb/assets/intro_modbustcp.pdf">[2]</a>,
hence each server or client can perform communication over
arbitrary lower level protocol stack. Two most common solutions are
TCP/IP and RTU (Remote Terminal Unit, which again is a sort of
abstraction, but typically means serial port communcation).</p>
<p><a class="el" href=
"classcutehmi_1_1modbus_1_1_abstract_device.html" title=
"Abstract Modbus device. ">cutehmi::modbus::AbstractDevice</a> is a
base class for all Modbus devices. It defines common features of
all Modbus devices.</p>
<p><a class="el" href=
"classcutehmi_1_1modbus_1_1_abstract_client.html" title=
"Abstract client. ">cutehmi::modbus::AbstractClient</a> and
<a class="el" href=
"classcutehmi_1_1modbus_1_1_abstract_server.html" title=
"Abstract server. ">cutehmi::modbus::AbstractServer</a> are
abstract classes for clients and servers respectively.</p>
<p><a class="el" href=
"classcutehmi_1_1modbus_1_1_r_t_u_client.html" title=
"Modbus TCP client. ">cutehmi::modbus::RTUClient</a> and <a class=
"el" href=
"classcutehmi_1_1modbus_1_1_r_t_u_server.html">cutehmi::modbus::RTUServer</a>
implement client and server functionalities using serial port
communication.</p>
<p><a class="el" href=
"classcutehmi_1_1modbus_1_1_t_c_p_client.html" title=
"Modbus TCP client. ">cutehmi::modbus::TCPClient</a> and <a class=
"el" href=
"classcutehmi_1_1modbus_1_1_t_c_p_server.html">cutehmi::modbus::TCPServer</a>
implement client and server functionalities using TCP/IP to
communicate.</p>
<p><a class="el" href=
"classcutehmi_1_1modbus_1_1_dummy_client.html" title=
"Dummy client. ">cutehmi::modbus::DummyClient</a> is a special
client that does not need a server to communicate with and it can
be used to test UI for example.</p>
<p>Device classes are lowest level API of the extension. They are
centered around an idea of JSON requests and replies, inspired by
web REST interfaces. Additionaly classes have various properties
allowing one to configure devices or check their statuses from
QML.</p>
<p>Device classes are intended to be used with <a href=
"../Services.2/index.html">CuteHMI.Services</a>. Notably device
object will not perform polling on its own. For this purpose device
classes implement <a class="elRef" doxygen=
"/home/cutebot/devel/cutehmi/extensions/CuteHMI/Services.2/doxygen.tag:../Services.2/"
href=
"../Services.2/classcutehmi_1_1services_1_1_serviceable.html">cutehmi::services::Serviceable</a>
interface. Device object must be embedded in <a class="elRef"
doxygen=
"/home/cutebot/devel/cutehmi/extensions/CuteHMI/Services.2/doxygen.tag:../Services.2/"
href=
"../Services.2/classcutehmi_1_1services_1_1_service.html">cutehmi::services::Service</a>
object to perform polling (after services are started by <a class=
"elRef" doxygen=
"/home/cutebot/devel/cutehmi/extensions/CuteHMI/Services.2/doxygen.tag:../Services.2/"
href=
"../Services.2/classcutehmi_1_1services_1_1_service_manager.html">cutehmi::services::ServiceManager</a>).
In return its state is managed by the state machine, which will
handle start/stop requests, try to repair broken connections
etc.</p>
<h2>Register controllers</h2>
<p>Modbus protocol is oriented around four classes of registers,
which can be viewed as four contiguous memory regions. These are:
holding registers, input registers, coils and discrete inputs.
Clients can read and write to holding registers and coils; input
registers and discrete inputs provide read-only access for clients.
Holding registers and input registers are addressed with 16 bit
byte, while byte is 1 bit wide for discrete inputs and coils (byte
is smallest addressable unit of memory).</p>
<p>While registers can be accessed with device classes, in most
cases imperative function calls do not fit well into QML
declarative syntax. Typically it is better to access a register
from QML using one of the controller classes. There is one
controller class for each of the Modbus register types: <a class=
"el" href=
"classcutehmi_1_1modbus_1_1_coil_controller.html">cutehmi::modbus::CoilController</a>,
<a class="el" href=
"classcutehmi_1_1modbus_1_1_discrete_input_controller.html">cutehmi::modbus::DiscreteInputController</a>,
<a class="el" href=
"classcutehmi_1_1modbus_1_1_input_register_controller.html">cutehmi::modbus::InputRegisterController</a>
and <a class="el" href=
"classcutehmi_1_1modbus_1_1_holding_register_controller.html">cutehmi::modbus::HoldingRegisterController</a>,
but they share most of the code, because there is not much of the
difference between them.</p>
<p>Controllers are better suited for accessing registers from QML,
because they reveal various register aspects through a set of
properties. They allow one to easily control how reads and writes
are performed. They track requests, interpret responses and
translate the sequence of events in between into convenient
signals. Their properties can be binded with other QML
components.</p>
<h2>Register items</h2>
<p>Register items are convenient components, which are composed of
a controller and visual indicator item. They are particularly
useful in "Design" mode. For each register controller there is
corresponding register item, that is: <a class="el" href=
"class_cute_h_m_i_1_1_modbus_1_1_coil_item.html" title=
"Coil item. ">CuteHMI::Modbus::CoilItem</a>, <a class="el" href=
"class_cute_h_m_i_1_1_modbus_1_1_discrete_input_item.html" title=
"Discrete input item. ">CuteHMI::Modbus::DiscreteInputItem</a>,
<a class="el" href=
"class_cute_h_m_i_1_1_modbus_1_1_holding_register_item.html" title=
"Holding register item. ">CuteHMI::Modbus::HoldingRegisterItem</a>
and <a class="el" href=
"class_cute_h_m_i_1_1_modbus_1_1_input_register_item.html" title=
"Input register item. ">CuteHMI::Modbus::InputRegisterItem</a>.</p>
<p>Relationship between extension classes is conceptually shown on
the following quasi-UML diagram.</p>
<div class="image"><object type="image/svg+xml" data=
"quasi_uml.svg">quasi_uml.svg</object>
<div class="caption">Relationship between extension classes</div>
</div>
</div>
</div>
<!-- contents --></div>
<!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath">
<!-- id is needed for treeview function! -->
<ul>
<li class="footer">Generated by <a href=
"http://www.doxygen.org/index.html"><img class="footer" src=
"doxygen.png" alt="doxygen" /></a> 1.8.14</li>
</ul>
</div>
</body>
</html>
